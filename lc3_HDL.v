/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
`include "spi_master.v"
`include "uart_tx.v"
`include "uart_rx.v"

`ifdef SIM_FPGA
`include "SB_SPRAM256KA.v"
`endif

module lc3_program_interface (
  input Clock,
  input running_in,
  input RX,
  output wire  SPI_MISO,
  output wire SPI_SCK,
  output wire SPI_SS,
  input wire  SPI_MOSI,
  output TX,
  output LED_B,
  output LED_G,
  output LED_R,
  output [15:0] mem_addr_out,
  output [15:0] mem_data_out,
  output mem_rw_out,
  output starting_out,
  output reset_out,
  input [15:0] mem_data_in
);

  reg [15:0] spram_addr;
  reg [15:0] spram_data_in;
  reg spram_wren;
  wire [15:0] spram_data_out;

  assign mem_addr_out = spram_addr;
  assign mem_data_out = spram_data_in;
  assign mem_rw_out   = spram_wren;
  assign spram_data_out = mem_data_in;

  localparam  INIT      = 0, 
              LOAD_OS   = INIT + 1, 
              LOAD_PROG = LOAD_OS + 1,
              READY     = LOAD_PROG + 1,
              RESETTING = READY + 1,
              DUMPING   = RESETTING + 1,
              STARTING  = DUMPING + 1,
              RUNNING   = STARTING + 1,
              DONE      = RUNNING + 1,
              STALLED   = DONE +1;

  localparam  FLASH_SEND_ADDR = 0,
              FLASH_WAIT_READ_FIRST = FLASH_SEND_ADDR + 1,
              FLASH_WAIT_READ_SECOND = FLASH_WAIT_READ_FIRST + 1,
              FLASH_READ_NEXT = FLASH_WAIT_READ_SECOND + 1;

  reg [21:0] led_counter = 0;
  reg [31:0] load_counter = 0;
  reg [3:0]  run_state = INIT;
  reg [3:0]  interuppted_state;
  reg [2:0]  led = 3'b000;
  reg        err = 0;

  reg [2:0] flash_read_state = FLASH_SEND_ADDR;

  reg [23:0] flash_addr;
  wire [31:0] flash_data;

  assign LED_B = ~led[0];
  assign LED_G = ~led[1];
  assign LED_R = ~led[2];

  reg spi_reset;
  wire spi_addr_buffer_free;
  reg spi_addr_en;
  wire spi_rd_data_available;
  reg spi_rd_ack;

  wire rx1_ready;
  wire [7:0] rx1_data;
  uart_rx #(12_000_000, 115_200) urx1 (
    .clk(Clock),
    .rx(RX),
    .rx_ready(rx1_ready),
    .rx_data(rx1_data)
  );

  reg tx1_start = 0;
  reg [7:0] tx1_data;
  wire tx1_busy;
  uart_tx #(12_000_000, 115_200) utx1 (
    .clk(Clock),
    .tx_start(tx1_start),
    .tx_data(tx1_data),
    .tx(TX),
    .tx_busy(tx1_busy)
  );

  spi_master spi_master_inst(
    .clk(Clock),
    .reset(spi_reset),
    .SPI_SCK(SPI_SCK),
    .SPI_SS(SPI_SS),
    .SPI_MOSI(SPI_MISO),
    .SPI_MISO(SPI_MOSI),
    .addr_buffer_free(spi_addr_buffer_free),
    .addr_en(spi_addr_en),
    .addr_data(flash_addr),
    .rd_data_available(spi_rd_data_available),
    .rd_ack(spi_rd_ack),
    .rd_data(flash_data)
  );

  task read_flash(input [3:0] next_run_state, input [15:0] limit);
  begin
    case (flash_read_state)
      FLASH_SEND_ADDR: begin
        spi_addr_en <= 1;
        flash_read_state <= FLASH_WAIT_READ_FIRST;
      end

      FLASH_WAIT_READ_FIRST: begin
        if (spi_rd_data_available == 1) begin
          spram_data_in <= flash_data[31:16];
          spram_wren <= 1;
          flash_read_state <= FLASH_WAIT_READ_SECOND;
        end
      end

      FLASH_WAIT_READ_SECOND: begin
          spram_addr <= spram_addr + 1;
          spram_data_in <= flash_data[15:0];
          spram_wren <= 1;
          spi_rd_ack <= 1;
          flash_read_state <= FLASH_READ_NEXT;
      end

      FLASH_READ_NEXT: begin
        if (spram_addr < limit - 1) begin
          flash_addr <= flash_addr + 4;
          spram_addr <= spram_addr + 1;
        end
        else begin
          run_state <= next_run_state;
        end
        flash_read_state <= FLASH_SEND_ADDR;
      end
      endcase
  end
  endtask
  
  localparam  UART_RX_WAIT_CMD = 0,
              UART_RX_WAIT_BYTE1 = UART_RX_WAIT_CMD + 1, 
              UART_RX_WAIT_BYTE2 = UART_RX_WAIT_BYTE1 + 1,
              UART_RX_WAIT_STOP = UART_RX_WAIT_BYTE2 + 1;

  localparam STATUS = 1, RUN = STATUS + 1, STOP = RUN + 1, LOAD = STOP + 1, DUMP = LOAD + 1, RESTART = DUMP + 1;

  localparam READING_MIN = 0, READING_MAX = READING_MIN + 1, SENDING = READING_MAX + 1, RECEIVING = SENDING + 1, INCREMENTING = RECEIVING + 1;

  localparam  UART_TX_IDLE = 0,
              UART_TX_WAIT_BYTE1 = UART_TX_IDLE + 1,
              UART_TX_WAIT_BYTE2 = UART_TX_WAIT_BYTE1 + 1;

  reg [2:0] uart_rx_state = UART_RX_WAIT_CMD;
  reg [7:0] uart_command = 0;
  reg [15:0] uart_command_arg;
  reg [15:0] uart_rx_short;
  reg uart_rx_short_ready;

  reg [3:0] dump_state;
  reg [3:0] load_state;
  reg [2:0] byte_count;
  reg [15:0] dump_max;
  reg [15:0] load_max;
  reg [3:0]  dump_clk_count;
  reg [1:0] starting;
  reg reset;

  assign starting_out = | starting;
  assign reset_out = reset;

  initial begin
    run_state = INIT;
    spi_reset = 0;
    spi_addr_en = 0;
    flash_addr = 24'h103000; //1MB offset
    spi_rd_ack = 0;
    spram_addr = 0;
    byte_count = 0;
    dump_clk_count = 0;
    uart_rx_short_ready = 0;
    starting = 0;
    reset = 0;
    tx1_start = 0;
  end

  // Handle incoming commands over UART
  always @(posedge Clock) begin
    spi_rd_ack <= 0;
    spi_addr_en <= 0;
    spram_wren <= 0;
    if (rx1_ready & ~tx1_start) begin
      if (uart_rx_state == UART_RX_WAIT_CMD) begin
        case(rx1_data)
          STATUS: begin
            tx1_data  <= run_state;
            tx1_start <= 1;
          end

          RUN: begin
            run_state <= STARTING;
            tx1_data <= 8'h00;
            tx1_start <= 1;
          end

          STOP: begin
            run_state <= DONE;
            reset <= 1;
            tx1_data <= 8'h00;
            tx1_start <= 1;
          end

          LOAD: begin
            run_state <= LOAD_PROG;
            load_state <= READING_MIN;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end

          DUMP: begin
            interuppted_state <= run_state;
            run_state <= DUMPING;
            dump_state <= READING_MIN;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end

          RESTART: begin
            run_state <= INIT;
            tx1_data <= 8'h00;
            tx1_start <= 1;
          end
          
        endcase 
      end else if (uart_rx_state == UART_RX_WAIT_BYTE1) begin
        uart_rx_short[15:8] <= rx1_data;
        uart_rx_state = UART_RX_WAIT_BYTE2;
      end else if (uart_rx_state == UART_RX_WAIT_BYTE2) begin
        uart_rx_short[7:0] <= rx1_data;
        uart_rx_short_ready <= 1;
        uart_rx_state = UART_RX_WAIT_CMD;
      end 
    end

    if (~tx1_busy & tx1_start) begin
      tx1_start <= 0;
    end

    spi_rd_ack <= 0;
    spi_addr_en <= 0;

    case (run_state)
    INIT: begin
      spi_reset  <= 1'b0;
      flash_addr <= 24'h100000;
      spram_addr <= 16'h0000;
      spram_wren <= 0;
      load_counter <= load_counter + 1;
      starting <= 0;

      if (load_counter == 32'h1000000) begin
        run_state  <= LOAD_OS;
        load_counter <= 0;
      end
    end

    LOAD_OS: begin
      reset <= 0;
      read_flash(RESETTING, 16'h3000);
    end

    RESETTING: begin
      if (spram_addr < 16'hFE00 - 1) begin
        spram_addr <= spram_addr + 1;
        spram_data_in <= 16'h0000;
        spram_wren <= 1;
      end else begin
        run_state <= READY;
      end
    end

    LOAD_PROG: begin
      case (load_state)
        READING_MIN: begin
          if (uart_rx_short_ready == 1) begin
            spram_addr <= uart_rx_short;
            load_state <= READING_MAX;
            uart_rx_short_ready <= 0;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end
        end

        READING_MAX: begin
          if (uart_rx_short_ready == 1) begin
            load_max <= uart_rx_short;
            load_state <= RECEIVING;
            uart_rx_short_ready <= 0;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end
        end

        RECEIVING: begin
          if (uart_rx_short_ready == 1) begin
            spram_data_in <= uart_rx_short;
            spram_wren <= 1;
            load_state <= INCREMENTING;
            uart_rx_short_ready <= 0;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end
        end

        INCREMENTING: begin
          if (spram_addr < load_max) begin
            spram_addr <= spram_addr + 1;
            load_state <= RECEIVING;
          end else begin
            if (tx1_busy == 0) begin
              tx1_data <= 0;
              tx1_start <= 1;
              run_state <= READY;
              uart_rx_state <= UART_RX_WAIT_CMD;
            end
          end
        end
      endcase
    end

    DUMPING: begin
      case (dump_state)
        READING_MIN: begin
          if (uart_rx_short_ready == 1) begin
            spram_addr <= uart_rx_short;
            dump_state <= READING_MAX;
            uart_rx_short_ready <= 0;
            uart_rx_state <= UART_RX_WAIT_BYTE1;
          end
        end

        READING_MAX: begin
          if (uart_rx_short_ready == 1) begin
            dump_max <= uart_rx_short;
            dump_state <= SENDING;
            uart_rx_short_ready <= 0;
            uart_rx_state <= UART_RX_WAIT_CMD;
          end
        end

        SENDING:begin
          if (tx1_busy == 0) begin
            if (spram_addr <= dump_max) begin
              dump_clk_count <= dump_clk_count + 1;
              if (dump_clk_count > 4 && byte_count < 2) begin
                if (byte_count == 0) begin
                  tx1_data <= spram_data_out[15:8];
                end else begin
                  tx1_data <= spram_data_out[7:0];
                  spram_addr <= spram_addr + 1;
                end
                tx1_start <= 1;
                byte_count <= byte_count + 1;
              end else if (byte_count >= 2) begin
                byte_count <= 0;                
                dump_clk_count <= 0;
              end
            end else begin
              run_state <= interuppted_state;
            end
          end
        end
      endcase
    end

    STARTING:begin
      if (starting < 3) begin
        starting <= starting + 1;
      end else begin;
        starting <= 0;
        run_state <= RUNNING;
      end
    end

    RUNNING: begin
      if (running_in == 0) begin
        run_state <= DONE;
      end
    end

    endcase
  end

  // Blink LED passed on current run state of the system.
  always @(posedge Clock) begin
    led_counter <= led_counter + 1;

    case (run_state)
    INIT: begin // Solid Red
      led <= 3'b100;
    end
    LOAD_OS: begin // Red <-> Green
      led <= {~led_counter[21], led_counter[21], 1'b0};
    end
    LOAD_PROG: begin // Blink Green
      led <= {1'b0, led_counter[21], 1'b0};
    end
    READY: begin // Solid Green
      led <= 3'b010;
    end
    RUNNING: begin // Solid Blue
      led <= 3'b001;
    end
    DONE: begin // Blink Green on success, Blink Red on err
      led <= {~led_counter[21] & err, led_counter[21] & ~err, 1'b0};
    end
    STALLED: begin // Blink Blue
      led <= {1'b0, 1'b0, led_counter[21]};
    end
    default: begin // Solid White (should not get here)
      led <= 3'b111;
    end
    endcase
  end

endmodule


module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule


module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module lc3_halt_HDL (
  input [15:0] MAR,
  input start,
  input \R.W ,
  input Clock,
  input reset,
  output Run
);
  wire m;
  wire s0;
  wire Run_temp;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( MAR ),
    .b( 16'b1111111111111110 ),
    .\= ( m )
  );
  assign s0 = ((start & ~ reset & ~ m) | (~ \R.W  & ~ reset & Run_temp) | (start & ~ reset & ~ \R.W ) | (~ m & ~ reset & Run_temp));
  // MCR
  DIG_Register DIG_Register_i1 (
    .D( s0 ),
    .C( Clock ),
    .en( Clock ),
    .Q( Run_temp )
  );
  assign Run = Run_temp;
endmodule

module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module Decoder3 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel
);
    assign out_0 = (sel == 3'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 3'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 3'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 3'h3)? 1'b1 : 1'b0;
    assign out_4 = (sel == 3'h4)? 1'b1 : 1'b0;
    assign out_5 = (sel == 3'h5)? 1'b1 : 1'b0;
    assign out_6 = (sel == 3'h6)? 1'b1 : 1'b0;
    assign out_7 = (sel == 3'h7)? 1'b1 : 1'b0;
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module lc3_register_file (
  input Clk,
  input [15:0] Data,
  input \LD.Reg ,
  input [2:0] DR,
  input [2:0] SR1,
  input [2:0] SR2,
  output [15:0] \SR2.OUT ,
  output [15:0] \SR1.OUT 
);
  wire R0;
  wire R1;
  wire R2;
  wire R3;
  wire R4;
  wire R5;
  wire R6;
  wire R7;
  wire s0;
  wire [15:0] s1;
  wire s2;
  wire [15:0] s3;
  wire s4;
  wire [15:0] s5;
  wire s6;
  wire [15:0] s7;
  wire s8;
  wire [15:0] s9;
  wire s10;
  wire [15:0] s11;
  wire s12;
  wire [15:0] s13;
  wire s14;
  wire [15:0] s15;
  Decoder3 Decoder3_i0 (
    .sel( DR ),
    .out_0( R0 ),
    .out_1( R1 ),
    .out_2( R2 ),
    .out_3( R3 ),
    .out_4( R4 ),
    .out_5( R5 ),
    .out_6( R6 ),
    .out_7( R7 )
  );
  assign s0 = (\LD.Reg  & R0);
  assign s2 = (\LD.Reg  & R1);
  assign s4 = (\LD.Reg  & R2);
  assign s6 = (\LD.Reg  & R3);
  assign s8 = (\LD.Reg  & R4);
  assign s10 = (\LD.Reg  & R5);
  assign s12 = (\LD.Reg  & R6);
  assign s14 = (\LD.Reg  & R7);
  // R0
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( Data ),
    .C( Clk ),
    .en( s0 ),
    .Q( s1 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( Data ),
    .C( Clk ),
    .en( s2 ),
    .Q( s3 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( Data ),
    .C( Clk ),
    .en( s4 ),
    .Q( s5 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( Data ),
    .C( Clk ),
    .en( s6 ),
    .Q( s7 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( Data ),
    .C( Clk ),
    .en( s8 ),
    .Q( s9 )
  );
  // R5
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( Data ),
    .C( Clk ),
    .en( s10 ),
    .Q( s11 )
  );
  // R6
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i7 (
    .D( Data ),
    .C( Clk ),
    .en( s12 ),
    .Q( s13 )
  );
  // R7
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i8 (
    .D( Data ),
    .C( Clk ),
    .en( s14 ),
    .Q( s15 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i9 (
    .sel( SR2 ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .out( \SR2.OUT  )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i10 (
    .sel( SR1 ),
    .in_0( s1 ),
    .in_1( s3 ),
    .in_2( s5 ),
    .in_3( s7 ),
    .in_4( s9 ),
    .in_5( s11 ),
    .in_6( s13 ),
    .in_7( s15 ),
    .out( \SR1.OUT  )
  );
endmodule

module lc3_microsequencer (
  input [5:0] J,
  input [2:0] COND,
  input IRD,
  input INT,
  input R,
  input [4:0] \IR[15:11] ,
  input BEN,
  input \PSR[15] ,
  input ACV,
  output [5:0] Addr
);
  wire COND0;
  wire COND1;
  wire COND2;
  wire [5:0] s0;
  wire [5:0] s1;
  assign s1[3:0] = \IR[15:11] [4:1];
  assign s1[5:4] = 2'b0;
  assign COND0 = COND[0];
  assign COND1 = COND[1];
  assign COND2 = COND[2];
  assign s0[0] = ((\IR[15:11] [0] & COND0 & COND1 & ~ COND2) | J[0]);
  assign s0[1] = ((R & COND0 & ~ COND1 & ~ COND2) | J[1]);
  assign s0[2] = ((BEN & ~ COND0 & COND1 & ~ COND2) | J[2]);
  assign s0[3] = ((\PSR[15]  & ~ COND0 & ~ COND1 & COND2) | J[3]);
  assign s0[4] = ((INT & COND0 & ~ COND1 & COND2) | J[4]);
  assign s0[5] = ((ACV & ~ COND0 & COND1 & COND2) | J[5]);
  Mux_2x1_NBits #(
    .Bits(6)
  )
  Mux_2x1_NBits_i0 (
    .sel( IRD ),
    .in_0( s0 ),
    .in_1( s1 ),
    .out( Addr )
  );
endmodule
module DIG_ROM_64X52_LC3Microcode (
    input [5:0] A,
    input sel,
    output reg [51:0] D
);
    reg [51:0] my_rom [0:61];

    always @ (*) begin
        if (~sel)
            D = 52'hz;
        else if (A > 6'h3d)
            D = 52'h0;
        else
            D = my_rom[A];
    end

    initial begin
        my_rom[0] = 52'h2480000000000;
        my_rom[1] = 52'h483004008000;
        my_rom[2] = 52'h8e0022002200;
        my_rom[3] = 52'h5e0022002200;
        my_rom[4] = 52'h3500000000000;
        my_rom[5] = 52'h483004008008;
        my_rom[6] = 52'h8e002200d200;
        my_rom[7] = 52'h5e002200d200;
        my_rom[8] = 52'h4920004010018;
        my_rom[9] = 52'h483004008010;
        my_rom[10] = 52'h460022002200;
        my_rom[11] = 52'h4e0022002200;
        my_rom[12] = 52'h480804088018;
        my_rom[13] = 52'h4950480400180;
        my_rom[14] = 52'h482002002200;
        my_rom[15] = 52'hbd0880400000;
        my_rom[16] = 52'h1400000000006;
        my_rom[17] = 52'h6600000000000;
        my_rom[18] = 52'h860830000000;
        my_rom[19] = 52'h6740000000000;
        my_rom[20] = 52'h48281012c000;
        my_rom[21] = 52'h482810123000;
        my_rom[22] = 52'h480802082200;
        my_rom[23] = 52'h6410004000018;
        my_rom[24] = 52'h1610000000004;
        my_rom[25] = 52'h1650000000004;
        my_rom[26] = 52'h8e0028000000;
        my_rom[27] = 52'h483008000000;
        my_rom[28] = 52'h1710000000004;
        my_rom[29] = 52'h1750000000004;
        my_rom[30] = 52'h808008000000;
        my_rom[31] = 52'h5e0028000000;
        my_rom[32] = 52'h8004000000000;
        my_rom[33] = 52'h6700000000000;
        my_rom[34] = 52'h4cc2000250000;
        my_rom[35] = 52'h6640000000000;
        my_rom[36] = 52'h1910000000004;
        my_rom[37] = 52'ha62000250400;
        my_rom[38] = 52'h9c0808080000;
        my_rom[39] = 52'ha22000250000;
        my_rom[40] = 52'h1a10000000004;
        my_rom[41] = 52'h1a40000000006;
        my_rom[42] = 52'h881448000020;
        my_rom[43] = 52'hb90000800000;
        my_rom[44] = 52'hb50480400140;
        my_rom[45] = 52'h942100250800;
        my_rom[46] = 52'hd22000250400;
        my_rom[47] = 52'h4940482000000;
        my_rom[48] = 52'hd504804001c0;
        my_rom[49] = 52'h4950480400100;
        my_rom[50] = 52'h0;
        my_rom[51] = 52'h480000000000;
        my_rom[52] = 52'h1d00000000006;
        my_rom[53] = 52'h1d50000000004;
        my_rom[54] = 52'hd60001000000;
        my_rom[55] = 52'h480808080000;
        my_rom[56] = 52'hb504804001c0;
        my_rom[57] = 52'hb504804001c0;
        my_rom[58] = 52'h0;
        my_rom[59] = 52'h482200250c00;
        my_rom[60] = 52'hb504804001c0;
        my_rom[61] = 52'hb504804001c0;
    end
endmodule


module lc3_control (
  input Clk,
  input INT,
  input R,
  input [4:0] \IR[15:11] ,
  input BEN,
  input \PSR[15] ,
  input ACV,
  output \LD.MAR ,
  output \LD.MDR ,
  output \LD.IR ,
  output \LD.BEN ,
  output \LD.REG ,
  output \LD.CC ,
  output \LD.PC ,
  output \LD.Priv ,
  output \LD.SavedSSP ,
  output \LD.SavedUSP ,
  output \LD.Vector ,
  output \LD.ACV ,
  output GatePC,
  output GateMDR,
  output GateALU,
  output GateMARMUX,
  output GateVector,
  output \GatePC-1 ,
  output GatePSR,
  output GateSP,
  output [1:0] PCMUX,
  output [1:0] DRMUX,
  output [1:0] SR1MUX,
  output [1:0] ADDR2MUX,
  output [1:0] SPMUX,
  output [1:0] ALUK,
  output ADDR1MUX,
  output MARMUX,
  output TableMUX,
  output PSRMUX,
  output \MIO.EN ,
  output \R.W ,
  output \Set.Priv ,
  output [5:0] State
);
  wire [5:0] State_temp;
  wire [51:0] s0;
  wire [5:0] s1;
  wire [2:0] s2;
  wire s3;
  wire s4;
  wire s5;
  wire [4:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire [41:0] s10;
  wire [9:0] \J,Cond,IRD ;
  wire [9:0] s11;
  wire [9:0] s12;
  wire [9:0] s13;
  assign s12[0] = INT;
  assign s12[1] = R;
  assign s12[6:2] = \IR[15:11] ;
  assign s12[7] = BEN;
  assign s12[8] = \PSR[15] ;
  assign s12[9] = ACV;
  DIG_Register_BUS #(
    .Bits(10)
  )
  DIG_Register_BUS_i0 (
    .D( s12 ),
    .C( Clk ),
    .en( Clk ),
    .Q( s13 )
  );
  assign s4 = s13[0];
  assign s5 = s13[1];
  assign s6 = s13[6:2];
  assign s7 = s13[7];
  assign s8 = s13[8];
  assign s9 = s13[9];
  lc3_microsequencer lc3_microsequencer_i1 (
    .J( s1 ),
    .COND( s2 ),
    .IRD( s3 ),
    .INT( s4 ),
    .R( s5 ),
    .\IR[15:11] ( s6 ),
    .BEN( s7 ),
    .\PSR[15] ( s8 ),
    .ACV( s9 ),
    .Addr( State_temp )
  );
  // LC3-Microcode
  DIG_ROM_64X52_LC3Microcode DIG_ROM_64X52_LC3Microcode_i2 (
    .A( State_temp ),
    .sel( 1'b1 ),
    .D( s0 )
  );
  assign s10 = s0[41:0];
  assign \J,Cond,IRD  = s0[51:42];
  DIG_Register_BUS #(
    .Bits(10)
  )
  DIG_Register_BUS_i3 (
    .D( \J,Cond,IRD  ),
    .C( Clk ),
    .en( Clk ),
    .Q( s11 )
  );
  assign \Set.Priv  = s10[0];
  assign \R.W  = s10[1];
  assign \MIO.EN  = s10[2];
  assign ALUK = s10[4:3];
  assign PSRMUX = s10[5];
  assign TableMUX = s10[8];
  assign MARMUX = s10[9];
  assign SPMUX = s10[11:10];
  assign ADDR2MUX = s10[13:12];
  assign ADDR1MUX = s10[14];
  assign SR1MUX = s10[16:15];
  assign DRMUX = s10[18:17];
  assign PCMUX = s10[20:19];
  assign GateSP = s10[21];
  assign GatePSR = s10[22];
  assign \GatePC-1  = s10[23];
  assign GateVector = s10[24];
  assign GateMARMUX = s10[25];
  assign GateALU = s10[26];
  assign GateMDR = s10[27];
  assign GatePC = s10[28];
  assign \LD.ACV  = s10[29];
  assign \LD.Vector  = s10[31];
  assign \LD.SavedUSP  = s10[32];
  assign \LD.SavedSSP  = s10[33];
  assign \LD.Priv  = s10[34];
  assign \LD.PC  = s10[35];
  assign \LD.CC  = s10[36];
  assign \LD.REG  = s10[37];
  assign \LD.BEN  = s10[38];
  assign \LD.IR  = s10[39];
  assign \LD.MDR  = s10[40];
  assign \LD.MAR  = s10[41];
  assign s1 = s11[5:0];
  assign s2 = s11[8:6];
  assign s3 = s11[9];
  assign State = State_temp;
endmodule
module pc (
    input wire[15:0] D,
    input wire C,
    input wire en,
    output reg [15:0] Q
);

reg [15:0] pc;

initial pc = 16'h0200;

always @ (posedge C) begin
    if(en === 1) pc = D;
    Q <= pc;
end

endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module DIG_Sub #(
    parameter Bits = 2
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits-1):0] s,
    output c_o
);
    wire [Bits:0] temp;

    assign temp = a - b - c_i;
    assign s = temp[(Bits-1):0];
    assign c_o = temp[Bits];
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module lc3_acv (
  input mode,
  input [6:0] in,
  input clk,
  input en,
  output ACV
);
  wire s0;
  assign s0 = (mode & (((~ in[6] & ~ in[5]) & (~ in[4] | ~ in[3])) | (in[6] & in[5] & in[4] & in[3] & in[2] & in[1] & in[0])));
  DIG_Register DIG_Register_i0 (
    .D( s0 ),
    .C( clk ),
    .en( en ),
    .Q( ACV )
  );
endmodule

module lc3_details_HDL (
  input Clk,
  input \LD.SavedSSP ,
  input \LD.SavedUSP ,
  input [1:0] SPMUX,
  input [15:0] \SR1.Val ,
  input TableMux,
  input \LD.Vector ,
  input N,
  input Z,
  input P,
  input [2:0] \IR[2:0] ,
  input \LD.BEN ,
  input \LD.ACV ,
  input \Set.Priv ,
  input PSRMux,
  input \LD.Priv ,
  input [15:0] Bus,
  output [15:0] SP,
  output [15:0] Vector,
  output [15:0] PSR,
  output BEN,
  output ACV,
  output \PSR[15] 
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [7:0] s4;
  wire [7:0] s5;
  wire [7:0] s6;
  wire s7;
  wire [6:0] s8;
  wire \PSR[15]_temp ;
  wire s9;
  wire s10;
  // Saved.USP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i0 (
    .D( \SR1.Val  ),
    .C( Clk ),
    .en( \LD.SavedUSP  ),
    .Q( s3 )
  );
  // Saved.SSP
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( \SR1.Val  ),
    .C( Clk ),
    .en( \LD.SavedSSP  ),
    .Q( s2 )
  );
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i2 (
    .a( \SR1.Val  ),
    .b( 16'b1 ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  DIG_Sub #(
    .Bits(16)
  )
  DIG_Sub_i3 (
    .a( \SR1.Val  ),
    .b( 16'b1 ),
    .c_i( 1'b0 ),
    .s( s1 )
  );
  assign s7 = ((N & \IR[2:0] [2]) | (Z & \IR[2:0] [1]) | (P & \IR[2:0] [0]));
  assign s6 = Bus[7:0];
  assign s8 = Bus[15:9];
  assign s10 = Bus[15];
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i4 (
    .sel( SPMUX ),
    .in_0( s0 ),
    .in_1( s1 ),
    .in_2( s2 ),
    .in_3( s3 ),
    .out( SP )
  );
  Mux_2x1_NBits #(
    .Bits(8)
  )
  Mux_2x1_NBits_i5 (
    .sel( TableMux ),
    .in_0( s6 ),
    .in_1( 8'b0 ),
    .out( s4 )
  );
  // BEN
  DIG_Register DIG_Register_i6 (
    .D( s7 ),
    .C( Clk ),
    .en( \LD.BEN  ),
    .Q( BEN )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( PSRMux ),
    .in_0( \Set.Priv  ),
    .in_1( s10 ),
    .out( s9 )
  );
  // Vector
  DIG_Register_BUS #(
    .Bits(8)
  )
  DIG_Register_BUS_i8 (
    .D( s4 ),
    .C( Clk ),
    .en( \LD.Vector  ),
    .Q( s5 )
  );
  // Priv
  DIG_Register DIG_Register_i9 (
    .D( s9 ),
    .C( Clk ),
    .en( \LD.Priv  ),
    .Q( \PSR[15]_temp  )
  );
  assign Vector[7:0] = s5;
  assign Vector[15:8] = 8'b0;
  lc3_acv lc3_acv_i10 (
    .mode( \PSR[15]_temp  ),
    .in( s8 ),
    .clk( Clk ),
    .en( \LD.ACV  ),
    .ACV( ACV )
  );
  assign PSR[0] = P;
  assign PSR[1] = Z;
  assign PSR[2] = N;
  assign PSR[14:3] = 12'b0;
  assign PSR[15] = \PSR[15]_temp ;
  assign \PSR[15]  = \PSR[15]_temp ;
endmodule
module PriorityEncoder2 (
    input in0,
    input in1,
    input in2,
    input in3,
    output reg [1:0] num,
    output any
);
    always @ (*) begin
        if (in3 == 1'b1)
            num = 2'h3;
        else if (in2 == 1'b1)
            num = 2'h2;
        else if (in1 == 1'b1)
            num = 2'h1;
        else 
            num = 2'h0;
    end

    assign any = in0 | in1 | in2 | in3;
endmodule


module lc3_memmap (
  input [15:0] addr,
  input en,
  input \R.W ,
  output [1:0] \MDR.Select ,
  output \MEM.EN ,
  output \LD.KBSR ,
  output \LD.DSR ,
  output \LD.DDR ,
  output \R.mapped 
);
  wire s0;
  wire s1;
  wire s2;
  wire NotMapped;
  wire \is.DDR ;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( addr ),
    .b( 16'b1111111000000000 ),
    .\= ( s0 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i1 (
    .a( addr ),
    .b( 16'b1111111000000010 ),
    .\= ( s1 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( addr ),
    .b( 16'b1111111000000100 ),
    .\= ( s2 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i3 (
    .a( addr ),
    .b( 16'b1111111000000110 ),
    .\= ( \is.DDR  )
  );
  assign NotMapped = ~ (s0 | s1 | s2);
  assign \LD.DSR  = (s2 & \R.W );
  assign \LD.KBSR  = (s0 & \R.W );
  assign \LD.DDR  = (\is.DDR  & \R.W );
  PriorityEncoder2 PriorityEncoder2_i4 (
    .in0( s0 ),
    .in1( s1 ),
    .in2( s2 ),
    .in3( NotMapped ),
    .num( \MDR.Select  )
  );
  assign \MEM.EN  = (en & NotMapped);
  assign \R.mapped  = (~ NotMapped | \is.DDR );
endmodule

module Decoder2 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel
);
    assign out_0 = (sel == 2'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 2'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 2'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 2'h3)? 1'b1 : 1'b0;
endmodule


module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule

`ifndef SYNTH_FPGA
module SB_SPRAM256KA (
    input [13:0] ADDRESS,
    input [15:0] DATAIN,
    input [3:0] MASKWREN,
    input WREN, CHIPSELECT, CLOCK, STANDBY, SLEEP, POWEROFF,
    output reg [15:0] DATAOUT
);
endmodule
`endif

module lc3_SPRAM_HDL (
  input [15:0] ADDRESS,
  input [15:0] DATAIN,
  input WREN,
  input CLOCK,
  output [15:0] DATAOUT,
  output R
);
  wire [13:0] s0;
  wire [3:0] s1;
  wire s2;
  wire [15:0] s3;
  wire [3:0] s4;
  wire s5;
  wire [15:0] s6;
  wire [3:0] s7;
  wire s8;
  wire [15:0] s9;
  wire [3:0] s10;
  wire s11;
  wire [15:0] s12;
  wire [1:0] s13;
  wire s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire [1:0] s19;
  wire s20;
  wire s21;
  assign s18 = ~ WREN;
  assign s13 = ADDRESS[15:14];
  assign s0 = ADDRESS[13:0];
  Decoder2 Decoder2_i0 (
    .sel( s13 ),
    .out_0( s14 ),
    .out_1( s15 ),
    .out_2( s16 ),
    .out_3( s17 )
  );
  DIG_Counter_Nbit #(
    .Bits(2)
  )
  DIG_Counter_Nbit_i1 (
    .en( s18 ),
    .C( CLOCK ),
    .clr( WREN ),
    .out( s19 )
  );
  assign s2 = (s14 & WREN);
  assign s5 = (s15 & WREN);
  assign s8 = (s16 & WREN);
  assign s11 = (s17 & WREN);
  CompUnsigned #(
    .Bits(2)
  )
  CompUnsigned_i2 (
    .a( s19 ),
    .b( 2'b11 ),
    .\> ( s20 ),
    .\= ( s21 )
  );
  assign s1[0] = s2;
  assign s1[1] = s2;
  assign s1[2] = s2;
  assign s1[3] = s2;
  assign s4[0] = s5;
  assign s4[1] = s5;
  assign s4[2] = s5;
  assign s4[3] = s5;
  assign s7[0] = s8;
  assign s7[1] = s8;
  assign s7[2] = s8;
  assign s7[3] = s8;
  assign s10[0] = s11;
  assign s10[1] = s11;
  assign s10[2] = s11;
  assign s10[3] = s11;
  assign R = (WREN | s20 | s21);
  // SB_SPRAM256KA
  SB_SPRAM256KA SB_SPRAM256KA_i3 (
    .ADDRESS( s0 ),
    .DATAIN( DATAIN ),
    .MASKWREN( s1 ),
    .WREN( s2 ),
    .CHIPSELECT( 1'b1 ),
    .CLOCK( CLOCK ),
    .STANDBY( 1'b0 ),
    .SLEEP( 1'b0 ),
    .POWEROFF( 1'b1 ),
    .DATAOUT( s3 )
  );
  // SB_SPRAM256KA
  SB_SPRAM256KA SB_SPRAM256KA_i4 (
    .ADDRESS( s0 ),
    .DATAIN( DATAIN ),
    .MASKWREN( s4 ),
    .WREN( s5 ),
    .CHIPSELECT( 1'b1 ),
    .CLOCK( CLOCK ),
    .STANDBY( 1'b0 ),
    .SLEEP( 1'b0 ),
    .POWEROFF( 1'b1 ),
    .DATAOUT( s6 )
  );
  // SB_SPRAM256KA
  SB_SPRAM256KA SB_SPRAM256KA_i5 (
    .ADDRESS( s0 ),
    .DATAIN( DATAIN ),
    .MASKWREN( s7 ),
    .WREN( s8 ),
    .CHIPSELECT( 1'b1 ),
    .CLOCK( CLOCK ),
    .STANDBY( 1'b0 ),
    .SLEEP( 1'b0 ),
    .POWEROFF( 1'b1 ),
    .DATAOUT( s9 )
  );
  // SB_SPRAM256KA
  SB_SPRAM256KA SB_SPRAM256KA_i6 (
    .ADDRESS( s0 ),
    .DATAIN( DATAIN ),
    .MASKWREN( s10 ),
    .WREN( s11 ),
    .CHIPSELECT( 1'b1 ),
    .CLOCK( CLOCK ),
    .STANDBY( 1'b0 ),
    .SLEEP( 1'b0 ),
    .POWEROFF( 1'b1 ),
    .DATAOUT( s12 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i7 (
    .sel( s13 ),
    .in_0( s3 ),
    .in_1( s6 ),
    .in_2( s9 ),
    .in_3( s12 ),
    .out( DATAOUT )
  );
endmodule

module DIG_CounterPreset #(
    parameter Bits = 2,
    parameter maxValue = 4
)
(
    input C,
    input en,
    input clr,
    input dir,
    input [(Bits-1):0] in,
    input ld,
    output [(Bits-1):0] out,
    output ovf
);

    reg [(Bits-1):0] count = 'h0;

    function [(Bits-1):0] maxVal (input [(Bits-1):0] maxv);
        if (maxv == 0)
            maxVal = (1 << Bits) - 1;
        else
            maxVal = maxv;
    endfunction

    assign out = count;
    assign ovf = ((count == maxVal(maxValue) & dir == 1'b0)
                  | (count == 'b0 & dir == 1'b1))? en : 1'b0;

    always @ (posedge C) begin
        if (clr == 1'b1)
            count <= 'h0;
        else if (ld == 1'b1)
            count <= in;
        else if (en == 1'b1) begin
            if (dir == 1'b0) begin
                if (count == maxVal(maxValue))
                    count <= 'h0;
                else
                    count <= count + 1'b1;
            end
            else begin
                if (count == 'h0)
                    count <= maxVal(maxValue);
                else
                    count <= count - 1;
            end
        end
    end
endmodule


module lc3_memory_HDL (
  input [15:0] Addr,
  input [15:0] D_in,
  input \R.W ,
  input Clk,
  input \MIO.EN ,
  input [15:0] KBSR,
  input [15:0] KBDR,
  input [15:0] DSR,
  input running,
  output [15:0] D_out,
  output R,
  output \LD.KBSR ,
  output \LD.DSR ,
  output \LD.DDR 
);
  wire [1:0] s0;
  wire \MEM.EN ;
  wire \R.mapped ;
  wire s1;
  wire [15:0] s2;
  wire s3;
  wire s4;
  lc3_memmap lc3_memmap_i0 (
    .addr( Addr ),
    .en( \MIO.EN  ),
    .\R.W ( \R.W  ),
    .\MDR.Select ( s0 ),
    .\MEM.EN ( \MEM.EN  ),
    .\LD.KBSR ( \LD.KBSR  ),
    .\LD.DSR ( \LD.DSR  ),
    .\LD.DDR ( \LD.DDR  ),
    .\R.mapped ( \R.mapped  )
  );
  assign s1 = ((~ running | \MEM.EN ) & \R.W );
  lc3_SPRAM_HDL lc3_SPRAM_HDL_i1 (
    .ADDRESS( Addr ),
    .DATAIN( D_in ),
    .WREN( s1 ),
    .CLOCK( Clk ),
    .DATAOUT( s2 )
  );
  assign s3 = ~ ((\MEM.EN  & ~ \R.W ) | s1);
  DIG_CounterPreset #(
    .Bits(3),
    .maxValue(4)
  )
  DIG_CounterPreset_i2 (
    .en( 1'b1 ),
    .C( Clk ),
    .dir( 1'b0 ),
    .in( 3'b0 ),
    .ld( 1'b0 ),
    .clr( s3 ),
    .ovf( s4 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i3 (
    .sel( s0 ),
    .in_0( KBSR ),
    .in_1( KBDR ),
    .in_2( DSR ),
    .in_3( s2 ),
    .out( D_out )
  );
  assign R = (s4 | \R.mapped );
endmodule

module lc3_breakpoint (
  input [15:0] Breakpoint,
  input [15:0] PC,
  input [5:0] State,
  input en
);
  wire s0;
  wire s1;
  wire s2;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( Breakpoint ),
    .b( PC ),
    .\= ( s0 )
  );
  CompUnsigned #(
    .Bits(6)
  )
  CompUnsigned_i1 (
    .a( State ),
    .b( 6'b10010 ),
    .\= ( s1 )
  );
  assign s2 = (en & s0 & s1);
endmodule
module PriorityEncoder3 (
    input in0,
    input in1,
    input in2,
    input in3,
    input in4,
    input in5,
    input in6,
    input in7,
    output reg [2:0] num,
    output any
);
    always @ (*) begin
        if (in7 == 1'b1)
            num = 3'h7;
        else if (in6 == 1'b1)
            num = 3'h6;
        else if (in5 == 1'b1)
            num = 3'h5;
        else if (in4 == 1'b1)
            num = 3'h4;
        else if (in3 == 1'b1)
            num = 3'h3;
        else if (in2 == 1'b1)
            num = 3'h2;
        else if (in1 == 1'b1)
            num = 3'h1;
        else 
            num = 3'h0;
    end

    assign any = in0 | in1 | in2 | in3 | in4 | in5 | in6 | in7;
endmodule

module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module lc3_alu (
  input [15:0] A,
  input [15:0] B,
  input [1:0] ALUK,
  output [15:0] ALU
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  // ADD
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i0 (
    .a( A ),
    .b( B ),
    .c_i( 1'b0 ),
    .s( s0 )
  );
  assign s1 = (A & B);
  assign s2 = ~ A;
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i1 (
    .sel( ALUK ),
    .in_0( s0 ),
    .in_1( s1 ),
    .in_2( s2 ),
    .in_3( A ),
    .out( ALU )
  );
endmodule

module lc3_cc_logic (
  input [15:0] D_in,
  output N,
  output Z,
  output P
);
  wire N_temp;
  wire Z_temp;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( D_in ),
    .b( 16'b0 ),
    .\= ( Z_temp )
  );
  assign N_temp = D_in[15];
  assign P = (~ Z_temp & ~ N_temp);
  assign N = N_temp;
  assign Z = Z_temp;
endmodule

module lc3_HDL (
  input RX,
  input SPI_MOSI,
  input Clock,
  output SPI_MISO,
  output SPI_SCK,
  output SPI_SS,
  output TX,
  output LED_B,
  output LED_G,
  output LED_R
);
  wire [15:0] ALU;
  wire [15:0] \SR1.OUT ;
  wire [15:0] s0;
  wire [1:0] ALUK;
  wire [15:0] s1;
  wire LED_G_temp;
  wire [15:0] Bus;
  wire \LD.REG ;
  wire [2:0] s2;
  wire [2:0] s3;
  wire [2:0] SR2;
  wire \LD.IR ;
  wire [15:0] s4;
  wire SR2MUX;
  wire [15:0] s5;
  wire [4:0] Immed;
  wire R;
  wire [4:0] \IR[15:11] ;
  wire BEN;
  wire \PSR[15] ;
  wire ACV;
  wire \LD.MAR ;
  wire \LD.MDR ;
  wire \LD.BEN ;
  wire \LD.CC ;
  wire \LD.PC ;
  wire \LD.Priv ;
  wire \LD.SavedSSP ;
  wire \LD.SavedUSP ;
  wire \LD.Vector ;
  wire \LD.ACV ;
  wire GatePC;
  wire GateMDR;
  wire GateALU;
  wire GateMARMUX;
  wire GateVector;
  wire \GatePC-1 ;
  wire GatePSR;
  wire GateSP;
  wire [1:0] PCMUX;
  wire [1:0] DRMUX;
  wire [1:0] SR1MUX;
  wire [1:0] ADDR2MUX;
  wire [1:0] SPMUX;
  wire ADDR1MUX;
  wire MARMUX;
  wire TableMux;
  wire PSRMux;
  wire \MIO.EN ;
  wire \R.W ;
  wire \Set.Priv ;
  wire [5:0] State;
  wire [15:0] s6;
  wire [15:0] s7;
  wire [15:0] MDR_out;
  wire [15:0] PC;
  wire [15:0] s8;
  wire [15:0] ADDER;
  wire [15:0] s9;
  wire s10;
  wire s11;
  wire s12;
  wire N;
  wire Z;
  wire P;
  wire [2:0] \IR[2:0] ;
  wire [2:0] SR1;
  wire [15:0] s13;
  wire [15:0] s14;
  wire [15:0] s15;
  wire [15:0] s16;
  wire [15:0] s17;
  wire [10:0] s18;
  wire [8:0] s19;
  wire [5:0] s20;
  wire [15:0] s21;
  wire [15:0] \MARMUX_{OUT} ;
  wire [15:0] d_out;
  wire [15:0] \PC-1 ;
  wire [2:0] s22;
  wire [15:0] PSR;
  wire [15:0] Vector;
  wire [15:0] SP;
  wire [15:0] MAR;
  wire starting;
  wire reset;
  wire running;
  wire [15:0] mem_in;
  wire mem_op;
  wire [15:0] KBSR;
  wire [15:0] KBDR;
  wire [15:0] DSR;
  wire \LD.KBSR ;
  wire \LD.DSR ;
  wire \LD.DDR ;
  wire s23;
  wire [15:0] addr;
  wire [15:0] d_in;
  wire rw;
  assign LED_B = 1'b1;
  // lc3_program_interface
  lc3_program_interface lc3_program_interface_i0 (
    .Clock( Clock ),
    .running_in( running ),
    .RX( RX ),
    .SPI_MOSI( SPI_MOSI ),
    .mem_data_in( d_out ),
    .SPI_MISO( SPI_MISO ),
    .SPI_SCK( SPI_SCK ),
    .SPI_SS( SPI_SS ),
    .TX( TX ),
    .LED_B( s23 ),
    .mem_addr_out( addr ),
    .mem_data_out( d_in ),
    .mem_rw_out( rw ),
    .starting_out( starting ),
    .reset_out( reset )
  );
  lc3_halt_HDL lc3_halt_HDL_i1 (
    .MAR( MAR ),
    .start( starting ),
    .\R.W ( \R.W  ),
    .Clock( Clock ),
    .reset( reset ),
    .Run( running )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( running ),
    .in_0( addr ),
    .in_1( s6 ),
    .out( MAR )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i3 (
    .sel( running ),
    .in_0( d_in ),
    .in_1( MDR_out ),
    .out( mem_in )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( running ),
    .in_0( rw ),
    .in_1( \R.W  ),
    .out( mem_op )
  );
  assign LED_G_temp = (Clock & running);
  // KBDR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( 16'b1 ),
    .C( LED_G_temp ),
    .en( 1'b1 ),
    .Q( KBDR )
  );
  lc3_register_file lc3_register_file_i6 (
    .Clk( LED_G_temp ),
    .Data( Bus ),
    .\LD.Reg ( \LD.REG  ),
    .DR( s2 ),
    .SR1( s3 ),
    .SR2( SR2 ),
    .\SR2.OUT ( s1 ),
    .\SR1.OUT ( \SR1.OUT  )
  );
  // IR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i7 (
    .D( Bus ),
    .C( LED_G_temp ),
    .en( \LD.IR  ),
    .Q( s4 )
  );
  lc3_control lc3_control_i8 (
    .Clk( LED_G_temp ),
    .INT( 1'b0 ),
    .R( R ),
    .\IR[15:11] ( \IR[15:11]  ),
    .BEN( BEN ),
    .\PSR[15] ( \PSR[15]  ),
    .ACV( ACV ),
    .\LD.MAR ( \LD.MAR  ),
    .\LD.MDR ( \LD.MDR  ),
    .\LD.IR ( \LD.IR  ),
    .\LD.BEN ( \LD.BEN  ),
    .\LD.REG ( \LD.REG  ),
    .\LD.CC ( \LD.CC  ),
    .\LD.PC ( \LD.PC  ),
    .\LD.Priv ( \LD.Priv  ),
    .\LD.SavedSSP ( \LD.SavedSSP  ),
    .\LD.SavedUSP ( \LD.SavedUSP  ),
    .\LD.Vector ( \LD.Vector  ),
    .\LD.ACV ( \LD.ACV  ),
    .GatePC( GatePC ),
    .GateMDR( GateMDR ),
    .GateALU( GateALU ),
    .GateMARMUX( GateMARMUX ),
    .GateVector( GateVector ),
    .\GatePC-1 ( \GatePC-1  ),
    .GatePSR( GatePSR ),
    .GateSP( GateSP ),
    .PCMUX( PCMUX ),
    .DRMUX( DRMUX ),
    .SR1MUX( SR1MUX ),
    .ADDR2MUX( ADDR2MUX ),
    .SPMUX( SPMUX ),
    .ALUK( ALUK ),
    .ADDR1MUX( ADDR1MUX ),
    .MARMUX( MARMUX ),
    .TableMUX( TableMux ),
    .PSRMUX( PSRMux ),
    .\MIO.EN ( \MIO.EN  ),
    .\R.W ( \R.W  ),
    .\Set.Priv ( \Set.Priv  ),
    .State( State )
  );
  // MAR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i9 (
    .D( Bus ),
    .C( LED_G_temp ),
    .en( \LD.MAR  ),
    .Q( s6 )
  );
  // MDR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i10 (
    .D( s7 ),
    .C( LED_G_temp ),
    .en( \LD.MDR  ),
    .Q( MDR_out )
  );
  DIG_Register DIG_Register_i11 (
    .D( s10 ),
    .C( LED_G_temp ),
    .en( \LD.CC  ),
    .Q( N )
  );
  DIG_Register DIG_Register_i12 (
    .D( s11 ),
    .C( LED_G_temp ),
    .en( \LD.CC  ),
    .Q( Z )
  );
  DIG_Register DIG_Register_i13 (
    .D( s12 ),
    .C( LED_G_temp ),
    .en( \LD.CC  ),
    .Q( P )
  );
  // pc
  pc pc_i14 (
    .D( s9 ),
    .C( LED_G_temp ),
    .en( \LD.PC  ),
    .Q( PC )
  );
  lc3_details_HDL lc3_details_HDL_i15 (
    .Clk( LED_G_temp ),
    .\LD.SavedSSP ( \LD.SavedSSP  ),
    .\LD.SavedUSP ( \LD.SavedUSP  ),
    .SPMUX( SPMUX ),
    .\SR1.Val ( \SR1.OUT  ),
    .TableMux( TableMux ),
    .\LD.Vector ( \LD.Vector  ),
    .N( N ),
    .Z( Z ),
    .P( P ),
    .\IR[2:0] ( \IR[2:0]  ),
    .\LD.BEN ( \LD.BEN  ),
    .\LD.ACV ( \LD.ACV  ),
    .\Set.Priv ( \Set.Priv  ),
    .PSRMux( PSRMux ),
    .\LD.Priv ( \LD.Priv  ),
    .Bus( Bus ),
    .SP( SP ),
    .Vector( Vector ),
    .PSR( PSR ),
    .BEN( BEN ),
    .ACV( ACV ),
    .\PSR[15] ( \PSR[15]  )
  );
  lc3_memory_HDL lc3_memory_HDL_i16 (
    .Addr( MAR ),
    .D_in( mem_in ),
    .\R.W ( mem_op ),
    .Clk( Clock ),
    .\MIO.EN ( \MIO.EN  ),
    .KBSR( KBSR ),
    .KBDR( KBDR ),
    .DSR( DSR ),
    .running( running ),
    .D_out( d_out ),
    .R( R ),
    .\LD.KBSR ( \LD.KBSR  ),
    .\LD.DSR ( \LD.DSR  ),
    .\LD.DDR ( \LD.DDR  )
  );
  // KBSR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i17 (
    .D( 16'b1 ),
    .C( LED_G_temp ),
    .en( \LD.KBSR  ),
    .Q( KBSR )
  );
  // DSR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i18 (
    .D( 16'b1 ),
    .C( LED_G_temp ),
    .en( \LD.DSR  ),
    .Q( DSR )
  );
  // DDR
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i19 (
    .D( MDR_out ),
    .C( LED_G_temp ),
    .en( \LD.DDR  )
  );
  // +1
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i20 (
    .a( PC ),
    .b( 16'b1 ),
    .c_i( 1'b0 ),
    .s( s8 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i21 (
    .sel( ADDR1MUX ),
    .in_0( PC ),
    .in_1( \SR1.OUT  ),
    .out( s14 )
  );
  assign s21[7:0] = s4[7:0];
  assign s21[15:8] = 8'b0;
  // -1
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i22 (
    .a( PC ),
    .b( 16'b1111111111111111 ),
    .c_i( 1'b0 ),
    .s( \PC-1  )
  );
  lc3_breakpoint lc3_breakpoint_i23 (
    .Breakpoint( 16'b0 ),
    .PC( PC ),
    .State( State ),
    .en( 1'b0 )
  );
  PriorityEncoder3 PriorityEncoder3_i24 (
    .in0( GateMARMUX ),
    .in1( \GatePC-1  ),
    .in2( GatePC ),
    .in3( GateALU ),
    .in4( GateMDR ),
    .in5( GatePSR ),
    .in6( GateVector ),
    .in7( GateSP ),
    .num( s22 )
  );
  DIG_Register DIG_Register_i25 (
    .D( 1'b1 ),
    .C( Clock ),
    .en( R ),
    .Q( LED_R )
  );
  assign Immed = s4[4:0];
  assign \IR[15:11]  = s4[15:11];
  assign SR2MUX = s4[5];
  assign \IR[2:0]  = s4[11:9];
  assign SR1 = s4[8:6];
  assign SR2 = s4[2:0];
  assign s18 = s4[10:0];
  assign s19 = s4[8:0];
  assign s20 = s4[5:0];
  // SEXT
  DIG_BitExtender #(
    .inputBits(5),
    .outputBits(16)
  )
  DIG_BitExtender_i26 (
    .in( Immed ),
    .out( s5 )
  );
  // SEXT
  DIG_BitExtender #(
    .inputBits(6),
    .outputBits(16)
  )
  DIG_BitExtender_i27 (
    .in( s20 ),
    .out( s15 )
  );
  // SEXT
  DIG_BitExtender #(
    .inputBits(9),
    .outputBits(16)
  )
  DIG_BitExtender_i28 (
    .in( s19 ),
    .out( s16 )
  );
  // SEXT
  DIG_BitExtender #(
    .inputBits(11),
    .outputBits(16)
  )
  DIG_BitExtender_i29 (
    .in( s18 ),
    .out( s17 )
  );
  Mux_4x1_NBits #(
    .Bits(3)
  )
  Mux_4x1_NBits_i30 (
    .sel( SR1MUX ),
    .in_0( \IR[2:0]  ),
    .in_1( SR1 ),
    .in_2( 3'b110 ),
    .in_3( 3'b0 ),
    .out( s3 )
  );
  Mux_4x1_NBits #(
    .Bits(3)
  )
  Mux_4x1_NBits_i31 (
    .sel( DRMUX ),
    .in_0( \IR[2:0]  ),
    .in_1( 3'b111 ),
    .in_2( 3'b110 ),
    .in_3( 3'b0 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i32 (
    .sel( SR2MUX ),
    .in_0( s1 ),
    .in_1( s5 ),
    .out( s0 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i33 (
    .sel( ADDR2MUX ),
    .in_0( 16'b0 ),
    .in_1( s15 ),
    .in_2( s16 ),
    .in_3( s17 ),
    .out( s13 )
  );
  lc3_alu lc3_alu_i34 (
    .A( \SR1.OUT  ),
    .B( s0 ),
    .ALUK( ALUK ),
    .ALU( ALU )
  );
  lc3_alu lc3_alu_i35 (
    .A( s13 ),
    .B( s14 ),
    .ALUK( 2'b0 ),
    .ALU( ADDER )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i36 (
    .sel( MARMUX ),
    .in_0( s21 ),
    .in_1( ADDER ),
    .out( \MARMUX_{OUT}  )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i37 (
    .sel( s22 ),
    .in_0( \MARMUX_{OUT}  ),
    .in_1( \PC-1  ),
    .in_2( PC ),
    .in_3( ALU ),
    .in_4( MDR_out ),
    .in_5( PSR ),
    .in_6( Vector ),
    .in_7( SP ),
    .out( Bus )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i38 (
    .sel( PCMUX ),
    .in_0( s8 ),
    .in_1( Bus ),
    .in_2( ADDER ),
    .in_3( 16'b0 ),
    .out( s9 )
  );
  lc3_cc_logic lc3_cc_logic_i39 (
    .D_in( Bus ),
    .N( s10 ),
    .Z( s11 ),
    .P( s12 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i40 (
    .sel( \MIO.EN  ),
    .in_0( Bus ),
    .in_1( d_out ),
    .out( s7 )
  );
  assign LED_G = LED_G_temp;
endmodule
